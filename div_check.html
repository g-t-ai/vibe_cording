<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>divレイアウト → エクセル風グリッド変換</title>
<style>
  :root{--bg:#0b1220;--pane:#0e1726;--card:#0f172a;--muted:#94a3b8;--txt:#e5e7eb;--line:#1f2937;--acc:#22d3ee;--sel:#0ea5b7;}
  html,body{height:100%}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;background:linear-gradient(120deg,#0b1220,#0a0f1c)}
  .wrap{max-width:1200px;margin:24px auto;padding:16px}
  .title{color:#e2e8f0;font-weight:700;font-size:20px;display:flex;gap:12px;align-items:center}
  .badge{font-size:12px;color:#a3e635;background:#17331a;border:1px solid #334155;border-radius:999px;padding:2px 8px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:14px}
  @media (max-width:980px){.grid2{grid-template-columns:1fr}}
  .card{background:rgba(17,24,39,.7);backdrop-filter:blur(6px);border:1px solid #1f2937;border-radius:16px;padding:14px;box-shadow:0 6px 30px rgba(0,0,0,.25)}
  .drop{min-height:320px;border:1px dashed #334155;border-radius:12px;background:#0b1220;color:#e5e7eb;padding:12px;overflow:auto}
  .drop:focus{outline:2px solid var(--acc)}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:10px 0}
  .controls label{color:#cbd5e1;font-size:13px}
  .controls input[type="number"], .controls input[type="text"]{
    background:#0b1220;border:1px solid #334155;border-radius:10px;color:#e5e7eb;padding:6px 10px;min-width:80px
  }
  .controls input[type="checkbox"]{transform:translateY(1px)}
  button{border:1px solid #334155;background:#0b1220;color:#e5e7eb;border-radius:12px;padding:8px 12px;cursor:pointer;transition:.15s}
  button:hover{transform:translateY(-1px);box-shadow:0 6px 16px rgba(0,0,0,.3)}
  .btn-pri{border-color:#0ea5b7;background:linear-gradient(90deg,#0ea5b7,#22d3ee);color:#0b1220;font-weight:700}

  /* Excel風グリッド */
  .xwrap{border:1px solid #334155;border-radius:12px;overflow:hidden;background:var(--pane)}
  .xhead{display:flex;align-items:center;gap:8px;padding:8px;border-bottom:1px solid #1f2937;background:#0e1726;color:#e5e7eb}
  .xgrid{width:100%;max-height:460px;overflow:auto;background:#0b1220}
  table.x{border-collapse:separate;border-spacing:0;width:100%;table-layout:fixed;color:var(--txt)}
  table.x th, table.x td{border-bottom:1px solid #1f2937;border-right:1px solid #1f2937;padding:6px 8px;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  table.x th:last-child, table.x td:last-child{border-right:none}
  table.x tr:last-child td{border-bottom:none}
  thead th{position:sticky;top:0;background:#0e1726;z-index:2}
  thead th.corner{left:0;z-index:3}
  tbody th.rowhead{position:sticky;left:0;background:#0e1726;color:#cbd5e1;z-index:1}
  thead th, tbody th.rowhead{font-weight:600;color:#cbd5e1}
  thead th, tbody th, td{min-width:90px}
  thead th:first-child, tbody th.rowhead{width:56px;min-width:56px;max-width:56px;text-align:right}
  /* 選択表示 */
  td.sel{outline:2px solid var(--sel);outline-offset:-2px;background:rgba(14,165,183,.15)}
  th.sel{background:#103544}
  /* 右側の出力テキスト */
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0b1220;border:1px solid #334155;color:#e5e7eb;border-radius:10px;padding:10px;min-height:100px}
  .hint{font-size:12px;color:var(--muted);margin:6px 0 0}
</style>
</head>
<body>
<div class="wrap">
  <div class="title">
    <span>🧩 divレイアウト → エクセル風グリッド変換</span>
    <span class="badge">縦範囲選択 & Ctrl/Cmd+C</span>
  </div>

  <div class="grid2">
    <!-- 左：貼り付け＆変換 -->
    <div class="card">
      <div style="display:flex;justify-content:space-between;gap:8px;align-items:center;margin-bottom:8px">
        <strong style="color:#e5e7eb">1) ここに請求画面の内容を貼り付け</strong>
        <div style="display:flex;gap:8px">
          <button id="btnClear">クリア</button>
          <button id="btnPaste">ペースト</button>
        </div>
      </div>
      <div id="paste" class="drop" contenteditable="true" spellcheck="false">
        <p style="color:#94a3b8">ここをクリックして <b>Ctrl/Cmd+V</b>。divで組んだ“表っぽい”HTMLでもOKです。</p>
      </div>
      <div class="controls">
        <label>行しきい値(px): <input id="rowTol" type="number" value="10" min="2" max="40"></label>
        <label>最小文字数: <input id="minChars" type="number" value="1" min="1" max="20"></label>
        <label>行セレクタ（任意）: <input id="rowSelector" type="text" placeholder=".invoice-row 等"></label>
        <label><input id="hasHeader" type="checkbox" checked> 先頭行をデータのヘッダーとみなす</label>
        <button class="btn-pri" id="btnConvert">変換</button>
      </div>
      <p class="hint">※ うまく並ばない場合は「行しきい値」を調整。セレクタが分かれば精度UP。</p>
    </div>

    <!-- 右：エクセル風 -->
    <div class="card">
      <div class="xwrap">
        <div class="xhead">
          <strong>2) エクセル風グリッド（範囲選択→コピー）</strong>
        </div>
        <div class="controls" style="padding:0 8px 8px">
          <label><input id="lockVertical" type="checkbox"> 列ドラッグ固定（縦方向だけ選択）</label>
          <label><input id="includeHeader" type="checkbox" checked> 先頭行（データのヘッダー）をコピーに含める</label>
          <button id="btnCopySelTSV">選択をTSVコピー</button>
          <button id="btnCopySelCSV">選択をCSVコピー</button>
          <button id="btnCopyAllTSV">全体TSV</button>
          <button id="btnCopyAllCSV">全体CSV</button>
        </div>
        <div id="gridHost" class="xgrid" tabindex="0" aria-label="エクセル風グリッド"></div>
      </div>
      <textarea id="txtOut" class="mono" placeholder="ここに選択範囲のTSV/CSV内容が出ます（確認用）"></textarea>
      <p class="hint">コツ：列ヘッダー（A,B,C…）をクリック→下方向にドラッグで縦範囲を素早く選択。Ctrl/Cmd+C でもコピーできます。</p>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (s, r=document) => r.querySelector(s);
  const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));

  const elPaste = $('#paste');
  const elRowTol = $('#rowTol');
  const elMinChars = $('#minChars');
  const elRowSelector = $('#rowSelector');
  const elHasHeader = $('#hasHeader');
  const elGridHost = $('#gridHost');
  const elOut = $('#txtOut');
  const elLockVertical = $('#lockVertical');
  const elIncludeHeader = $('#includeHeader');

  let state = {
    data: [],          // 2D array (rows x cols). data[0] は先頭行(ヘッダー扱い可)
    hasHeaderData: true,
    sel: null,         // {r1,c1,r2,c2}
    dragging: false,
    dragOrigin: null,  // 'cell' | 'colHeader' | 'rowHeader' | 'corner'
    cells: [],         // DOM参照 [r][c] -> TD
    colHeads: [],      // DOM参照 [c] -> TH
    rowHeads: []       // DOM参照 [r] -> TH
  };

  // 左ペインの操作
  $('#btnClear').addEventListener('click', () => {
    elPaste.innerHTML = '';
    elGridHost.innerHTML = '';
    elOut.value = '';
    state = {...state, data: [], sel:null, cells:[], colHeads:[], rowHeads:[]};
  });
  $('#btnPaste').addEventListener('click', async () => {
    try{
      const text = await navigator.clipboard.readText();
      if(text) {
        if (text.trim().startsWith('<') && text.includes('>')) elPaste.innerHTML = sanitizeHTML(text);
        else elPaste.textContent = text;
      }
    }catch(e){ alert('クリップボードから読み取れませんでした。権限をご確認ください。'); }
  });
  $('#btnConvert').addEventListener('click', () => {
    const html = elPaste.innerHTML;
    if(!html || !html.trim()){ alert('左側に貼り付けてから実行してください'); return; }
    const res = convertToTable(html, {
      rowTolerance: clamp(parseInt(elRowTol.value||10,10),2,80),
      minChars: clamp(parseInt(elMinChars.value||1,10),1,50),
      rowSelector: elRowSelector.value.trim() || null,
      header: elHasHeader.checked
    });
    state.hasHeaderData = elHasHeader.checked;
    state.data = res.rows; // matrix
    buildExcelGrid(state.data);
    elOut.value = '';
    toast('グリッドを更新しました');
  });

  // ============ Excel風グリッド生成 ============
  function buildExcelGrid(matrix){
    elGridHost.innerHTML = '';
    state.sel = null; state.cells = []; state.colHeads = []; state.rowHeads = [];
    const rows = matrix.length, cols = matrix.reduce((m,r)=>Math.max(m,r.length),0);

    const table = document.createElement('table');
    table.className = 'x';
    table.setAttribute('role','grid');
    table.setAttribute('aria-rowcount', String(rows));
    table.setAttribute('aria-colcount', String(cols));

    // THEAD: コーナー + A..Z..
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');

    const corner = document.createElement('th');
    corner.className = 'corner';
    corner.textContent = ' ';
    corner.style.position = 'sticky';
    corner.style.left = '0';
    corner.addEventListener('mousedown', e => {
      e.preventDefault();
      state.dragging = true;
      state.dragOrigin = 'corner';
      setSelection(0,0,rows-1,cols-1);
    });
    trh.appendChild(corner);

    for(let c=0;c<cols;c++){
      const th = document.createElement('th');
      th.textContent = colName(c);
      th.dataset.col = c;
      th.addEventListener('mousedown', e => {
        e.preventDefault();
        state.dragging = true;
        state.dragOrigin = 'colHeader';
        setSelection(0,c,rows-1,c);
      });
      state.colHeads[c] = th;
      trh.appendChild(th);
    }
    thead.appendChild(trh);
    table.appendChild(thead);

    // TBODY
    const tbody = document.createElement('tbody');
    for(let r=0;r<rows;r++){
      const tr = document.createElement('tr');

      // Row header
      const rh = document.createElement('th');
      rh.className = 'rowhead';
      rh.textContent = String(r+1);
      rh.dataset.row = r;
      rh.addEventListener('mousedown', e => {
        e.preventDefault();
        state.dragging = true;
        state.dragOrigin = 'rowHeader';
        setSelection(r,0,r,cols-1);
      });
      state.rowHeads[r] = rh;
      tr.appendChild(rh);

      state.cells[r] = [];
      for(let c=0;c<cols;c++){
        const td = document.createElement('td');
        td.textContent = (matrix[r] && matrix[r][c] != null) ? matrix[r][c] : '';
        td.dataset.r = r; td.dataset.c = c;
        td.addEventListener('mousedown', e => {
          e.preventDefault();
          state.dragging = true;
          state.dragOrigin = 'cell';
          setSelection(r,c,r,c);
        });
        td.addEventListener('mouseover', () => {
          if(!state.dragging) return;
          const lockCol = elLockVertical.checked || state.dragOrigin === 'colHeader';
          const lockRow = state.dragOrigin === 'rowHeader';
          const {r1,c1,r2,c2} = state.sel || {r1:r,c1:c,r2:r,c2:c};
          const nr2 = Math.max(Math.min(r, rows-1), 0);
          const nc2 = Math.max(Math.min(c, cols-1), 0);
          if(lockCol) setSelection(Math.min(r1,nr2), c1, Math.max(r1,nr2), c1);
          else if(lockRow) setSelection(r1, Math.min(c1,nc2), r1, Math.max(c1,nc2));
          else setSelection(Math.min(r1,nr2), Math.min(c1,nc2), Math.max(r1,nr2), Math.max(c1,nc2));
        });
        state.cells[r][c] = td;
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    elGridHost.appendChild(table);

    // マウスアップでドラッグ終了
    document.addEventListener('mouseup', onGlobalMouseUp);
    elGridHost.addEventListener('mouseleave', e => { /* 何もしない。スクロールでも選択は維持 */ });

    // キー操作: Ctrl/Cmd+C / Ctrl+A
    elGridHost.addEventListener('keydown', (e) => {
      if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='c'){
        e.preventDefault(); copySelection('tsv');
      } else if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='a'){
        e.preventDefault(); setSelection(0,0,rows-1,cols-1);
      }
    });

    // 初期選択
    if(rows && cols) setSelection( state.hasHeaderData ? 1 : 0 , 0, rows-1, 0); // データ最左列（ヘッダーがあれば2行目から）
  }

  function onGlobalMouseUp(){
    if(state.dragging){ state.dragging = false; state.dragOrigin = null; }
  }

  // 選択の描画・保存
  function setSelection(r1,c1,r2,c2){
    if(!state.cells.length) return;
    // 正規化
    const R1 = Math.max(0, Math.min(r1,r2));
    const C1 = Math.max(0, Math.min(c1,c2));
    const R2 = Math.max(0, Math.max(r1,r2));
    const C2 = Math.max(0, Math.max(c1,c2));
    state.sel = {r1:R1,c1:C1,r2:R2,c2:C2};

    // クリア
    for(const row of state.cells) for(const td of row) td.classList.remove('sel');
    for(const th of state.colHeads) th && th.classList.remove('sel');
    for(const th of state.rowHeads) th && th.classList.remove('sel');

    // 付与
    for(let r=R1;r<=R2;r++){
      state.rowHeads[r]?.classList.add('sel');
      for(let c=C1;c<=C2;c++){
        state.cells[r][c]?.classList.add('sel');
      }
    }
    for(let c=C1;c<=C2;c++) state.colHeads[c]?.classList.add('sel');
  }

  // コピー系
  $('#btnCopySelTSV').addEventListener('click', () => copySelection('tsv'));
  $('#btnCopySelCSV').addEventListener('click', () => copySelection('csv'));
  $('#btnCopyAllTSV').addEventListener('click', () => copyAll('tsv'));
  $('#btnCopyAllCSV').addEventListener('click', () => copyAll('csv'));

  function copySelection(kind){
    if(!state.sel){ alert('選択範囲がありません'); return; }
    const {r1,c1,r2,c2} = state.sel;
    const includeHdr = elIncludeHeader.checked && state.hasHeaderData;
    const rows = [];

    // 先頭行（データのヘッダー）を追加（選択にヘッダーが含まれていない場合のみ）
    if(includeHdr && r1>0){
      const hdr = [];
      for(let c=c1;c<=c2;c++) hdr.push(safe(state.data[0]?.[c]));
      rows.push(hdr);
    }
    for(let r=r1;r<=r2;r++){
      const line = [];
      for(let c=c1;c<=c2;c++) line.push(safe(state.data[r]?.[c]));
      rows.push(line);
    }

    const tsv = rows.map(r => r.map(v => (v||'').replace(/\t/g,' ')).join('\t')).join('\n');
    const csv = tsvToCsv(tsv);
    const text = (kind==='csv') ? csv : tsv;
    elOut.value = text;
    writeClipboard(text).then(()=>toast(`${kind.toUpperCase()}をコピーしました`)).catch(()=>alert('コピーに失敗しました'));
  }

  function copyAll(kind){
    if(!state.data.length){ alert('データがありません'); return; }
    const tsv = state.data.map(r => r.map(v => (v||'').replace(/\t/g,' ')).join('\t')).join('\n');
    const csv = tsvToCsv(tsv);
    const text = (kind==='csv') ? csv : tsv;
    elOut.value = text;
    writeClipboard(text).then(()=>toast(`全体${kind.toUpperCase()}をコピーしました`)).catch(()=>alert('コピーに失敗しました'));
  }

  function writeClipboard(text){
    if(navigator.clipboard?.writeText) return navigator.clipboard.writeText(text);
    // 古いブラウザ向けフォールバック
    const ta = document.createElement('textarea');
    ta.value = text; document.body.appendChild(ta); ta.select();
    const ok = document.execCommand('copy'); document.body.removeChild(ta);
    return ok ? Promise.resolve() : Promise.reject();
  }

  // ============ 変換ロジック（前回の改良） ============
  function sanitizeHTML(html){
    const tpl = document.createElement('template');
    tpl.innerHTML = html;
    $$('script,style,iframe,object,embed,link', tpl.content).forEach(el => el.remove());
    $$('img', tpl.content).forEach(img => {
      const alt = (img.getAttribute('alt')||'').trim();
      const span = document.createElement('span');
      span.textContent = alt ? `[画像:${alt}]` : '';
      img.replaceWith(span);
    });
    return tpl.innerHTML;
  }

  function convertToTable(sourceHTML, opt){
    const {rowTolerance, minChars, rowSelector, header} = opt;
    const host = document.createElement('div');
    host.style.cssText = 'position:fixed;left:-99999px;top:0;width:1200px;height:auto;opacity:0;pointer-events:none;z-index:-1;';
    host.innerHTML = sanitizeHTML(sourceHTML);
    document.body.appendChild(host);

    let rows = [];
    if (rowSelector) {
      rows = $$(rowSelector, host).map(el => {
        return pickLeafTextElements(el, minChars)
          .map(e => ({el:e, rect:e.getBoundingClientRect()}))
          .sort((a,b)=>a.rect.left-b.rect.left)
          .map(x => cleanText(x.el.textContent));
      }).filter(r=>r.some(c=>c));
    } else {
      const leaves = pickLeafTextElements(host, minChars);
      const items = leaves.map(el => ({ el, rect: el.getBoundingClientRect(), text: cleanText(el.textContent) }))
                          .filter(x => x.text.length >= minChars);
      const bucket = new Map();
      for(const it of items){
        const top = it.rect.top;
        const key = Math.round(top/rowTolerance)*rowTolerance;
        if(!bucket.has(key)) bucket.set(key, []);
        bucket.get(key).push(it);
      }
      const keys = Array.from(bucket.keys()).sort((a,b)=>a-b);
      rows = keys.map(k => bucket.get(k)
        .sort((a,b)=>a.rect.left-b.rect.left)
        .map(x=>x.text))
        .filter(r=>r.some(c=>c));
    }
    document.body.removeChild(host);

    const cols = rows.reduce((m,r)=>Math.max(m,r.length),0);
    const matrix = rows.map(r => {
      const a = r.slice(0, cols);
      while(a.length<cols) a.push('');
      return a;
    });

    const tsv = matrix.map(row => row.map(v => v.replace(/\t/g,' ')).join('\t')).join('\n');
    const csv = tsvToCsv(tsv);
    return { tsv, csv, rows: matrix };
  }

  function pickLeafTextElements(root, minChars){
    const all = $$('*', root);
    const hasText = el => (el.textContent||'').replace(/\s+/g,' ').trim().length >= minChars;
    const result = [];
    for(const el of all){
      if (['SCRIPT','STYLE'].includes(el.tagName)) continue;
      if (!hasText(el)) continue;
      const richChild = $$( '*', el ).some(ch => hasText(ch));
      if(!richChild) result.push(el);
    }
    return result.filter(el => {
      const rect = el.getBoundingClientRect();
      return rect.width*rect.height > 0.5;
    });
  }

  // ユーティリティ
  function tsvToCsv(tsv){
    const lines = tsv.split(/\r?\n/);
    return lines.map(line=>{
      const cells = line.split('\t').map(c=>{
        const needsQuote = /[",\n]/.test(c);
        let val = c.replace(/"/g,'""');
        return needsQuote ? `"${val}"` : val;
      });
      return cells.join(',');
    }).join('\n');
  }
  function safe(v){ return (v==null)?'':String(v); }
  function cleanText(s){ return (s||'').replace(/\s+/g,' ').replace(/\u00A0/g,' ').trim(); }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function colName(i){
    let name = ''; let n = i;
    do { name = String.fromCharCode(65 + (n % 26)) + name; n = Math.floor(n/26) - 1; } while(n>=0);
    return name;
  }
  function toast(msg){
    const el = document.createElement('div');
    el.textContent = msg;
    el.style.cssText = 'position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#0ea5b7;color:#0b1220;padding:8px 12px;border-radius:999px;font-weight:700;z-index:9999';
    document.body.appendChild(el);
    setTimeout(()=>{el.remove();}, 1600);
  }
})();
</script>
</body>
</html>
